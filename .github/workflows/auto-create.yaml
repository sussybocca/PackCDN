name: Autoâ€‘link Imagine Files

on:
  push:
    paths:
      - 'public/imagine/**'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-selector:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # ---- Install dependencies from JSX files ----
      - name: Install JSX dependencies
        run: |
          JSX_DIR="public/imagine/JSX"
          if [ -d "$JSX_DIR" ]; then
            echo "ðŸ” Scanning for JSX files to check dependencies..."
            TEMP_DEPS_FILE=$(mktemp)
            find "$JSX_DIR" -type f \( -name "*.jsx" -o -name "*.tsx" \) | while read -r file; do
              echo "Checking $file for dependencies..."
              grep -E "^import.*from|^import.*['\"]" "$file" | while read -r line; do
                if [[ $line =~ from[[:space:]]+[\'\"]([^\./][^\'\"]*)[\'\"] ]]; then
                  pkg="${BASH_REMATCH[1]}"
                  if [[ $pkg == @*/* ]]; then
                    echo "$pkg" >> "$TEMP_DEPS_FILE"
                  else
                    base_pkg=$(echo "$pkg" | cut -d'/' -f1)
                    echo "$base_pkg" >> "$TEMP_DEPS_FILE"
                  fi
                fi
              done
            done
            if [ -s "$TEMP_DEPS_FILE" ]; then
              sort -u "$TEMP_DEPS_FILE" > "${TEMP_DEPS_FILE}_unique"
              DEPS_TO_INSTALL=$(cat "${TEMP_DEPS_FILE}_unique" | tr '\n' ' ')
              if [ -n "$DEPS_TO_INSTALL" ]; then
                echo "ðŸ“¦ Dependencies found: $DEPS_TO_INSTALL"
                for pkg in $DEPS_TO_INSTALL; do
                  echo "ðŸ”§ Installing $pkg..."
                  if npm list "$pkg" --depth=0 2>/dev/null | grep -q "$pkg"; then
                    echo "âœ… $pkg already installed, skipping..."
                  else
                    if npm show "$pkg" version --json 2>/dev/null; then
                      npm install --save-exact "$pkg" --no-package-lock || npm install "$pkg" --no-package-lock
                    else
                      echo "âš ï¸ Could not find package $pkg, trying npm install anyway..."
                      npm install "$pkg" --no-package-lock || true
                    fi
                  fi
                done
                if [ -f "package-lock.json" ]; then
                  npm install --package-lock-only
                fi
              fi
            else
              echo "No dependencies found in JSX files."
            fi
            rm -f "$TEMP_DEPS_FILE" "${TEMP_DEPS_FILE}_unique"
          else
            echo "ðŸ“ JSX folder not found, skipping dependency installation."
          fi

      # ---- Install React if needed ----
      - name: Install React dependencies
        run: |
          JSX_DIR="public/imagine/JSX"
          if [ -d "$JSX_DIR" ] && find "$JSX_DIR" -name "*.jsx" -o -name "*.tsx" | grep -q .; then
            if find "$JSX_DIR" -type f \( -name "*.jsx" -o -name "*.tsx" \) -exec grep -l "React" {} \; | grep -q .; then
              if ! npm list react --depth=0 2>/dev/null | grep -q react; then
                echo "ðŸ“¦ Installing React..."
                npm install --save-exact react react-dom --no-package-lock || npm install react react-dom --no-package-lock
              fi
            fi
            if [ -f "package-lock.json" ]; then
              npm install --package-lock-only
            fi
          fi

      # ---- Install esbuild for compilation ----
      - name: Install esbuild
        run: npm install --no-save --no-package-lock esbuild

      # ---- Compile all JSX/TSX files and generate HTML wrappers ----
      - name: Compile JSX and generate HTML
        run: |
          JSX_DIR="public/imagine/JSX"
          COMPILED_DIR="public/imagine/compiled"
          mkdir -p "$COMPILED_DIR"

          if [ -d "$JSX_DIR" ]; then
            for file in $(find "$JSX_DIR" -type f \( -name "*.jsx" -o -name "*.tsx" \)); do
              echo "âš™ï¸ Compiling $file..."
              filename=$(basename "$file" .jsx)
              filename=$(basename "$filename" .tsx)
              outfile="$COMPILED_DIR/${filename}.js"

              # Bundle with esbuild, treating React as external (provided by CDN)
              npx esbuild "$file" --bundle --format=esm --external:react --external:react-dom --outfile="$outfile"

              # Generate a simple HTML file that loads React and the compiled script
              htmlfile="$COMPILED_DIR/${filename}.html"
              cat > "$htmlfile" <<EOF
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>${filename}</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="module">
    import App from './${filename}.js';
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.createElement(App);
  </script>
</body>
</html>
EOF
              echo "âœ… Generated $htmlfile"
            done
          else
            echo "No JSX folder, skipping compilation."
          fi

      # ---- Update selector.html with new imagine files (HTML and compiled HTML) ----
      - name: Update selector.html with new imagine files
        uses: actions/github-script@v7
        env:
          NODE_PATH: ${{ github.workspace }}/node_modules
        with:
          script: |
            (async () => {
              const fs = require('fs');
              const path = require('path');
              const util = require('util');
              const execAsync = util.promisify(require('child_process').exec);

              const workspace = process.env.GITHUB_WORKSPACE;
              const nodeModulesPath = path.join(workspace, 'node_modules');

              // Ensure node-html-parser is installed
              try {
                require.resolve('node-html-parser', { paths: [nodeModulesPath] });
              } catch (e) {
                console.log('node-html-parser not found, installing now...');
                await execAsync('npm install --no-save --no-package-lock node-html-parser', { cwd: workspace });
              }
              const { parse } = require('node-html-parser');

              const selectorPath = 'public/selector.html';
              const imagineDir = 'public/imagine';

              const selectorHtml = fs.readFileSync(selectorPath, 'utf8');
              const root = parse(selectorHtml);

              // Find cardsData script
              const scripts = root.querySelectorAll('script');
              let cardsDataScript = null;
              for (const script of scripts) {
                const content = script.textContent || script.innerHTML;
                if (content.includes('const cardsData = [')) {
                  cardsDataScript = script;
                  break;
                }
              }
              if (!cardsDataScript) {
                core.setFailed('Could not find cardsData array in selector.html');
                return;
              }

              const scriptContent = cardsDataScript.textContent;
              const match = scriptContent.match(/const cardsData = (\[[\s\S]*?\]);/);
              if (!match) {
                core.setFailed('Failed to extract cardsData array');
                return;
              }
              const cardsDataStr = match[1];
              let cardsData;
              try {
                cardsData = eval('(' + cardsDataStr + ')');
              } catch (e) {
                core.setFailed('Error parsing cardsData: ' + e.message);
                return;
              }

              // Gather all HTML files (including the newly generated ones in compiled/)
              function getAllHtmlFiles(dir, baseDir = dir) {
                let results = [];
                const list = fs.readdirSync(dir);
                for (const item of list) {
                  const fullPath = path.join(dir, item);
                  const stat = fs.statSync(fullPath);
                  if (stat.isDirectory()) {
                    results = results.concat(getAllHtmlFiles(fullPath, baseDir));
                  } else if (item.endsWith('.html')) {
                    const relativePath = path.relative(baseDir, fullPath);
                    results.push({ fullPath, relativePath });
                  }
                }
                return results;
              }

              if (!fs.existsSync(imagineDir)) {
                console.log('âš ï¸  imagine/ folder not found â€“ nothing to do.');
                return;
              }

              const files = getAllHtmlFiles(imagineDir);
              if (files.length === 0) {
                console.log('No HTML files found in imagine/ â€“ nothing to do.');
                return;
              }

              // Helper: extract title from HTML
              function extractTitle(filePath) {
                try {
                  const content = fs.readFileSync(filePath, 'utf8');
                  const doc = parse(content);
                  const titleTag = doc.querySelector('title');
                  return titleTag ? titleTag.text.trim() : null;
                } catch {
                  return null;
                }
              }

              // Helper: extract description
              function extractDescription(filePath) {
                try {
                  const content = fs.readFileSync(filePath, 'utf8');
                  const doc = parse(content);
                  const metaDesc = doc.querySelector('meta[name="description"]');
                  if (metaDesc) return metaDesc.getAttribute('content') || '';
                  const firstP = doc.querySelector('p');
                  if (firstP) return firstP.text.trim().substring(0, 150) + 'â€¦';
                } catch {}
                return 'Explore this immersive experience.';
              }

              // Helper: extract category (default 'demos', but for compiled files we may set a different one)
              function extractCategory(filePath) {
                if (filePath.includes('/compiled/')) return 'jsx-demo';
                return 'demos';
              }

              function cardExists(link) {
                return cardsData.some(card => card.link === link);
              }

              let addedCount = 0;
              for (const { fullPath, relativePath } of files) {
                const link = `imagine/${relativePath.replace(/\\/g, '/')}`;
                if (cardExists(link)) {
                  console.log(`Card for ${relativePath} already exists â€“ skipping.`);
                  continue;
                }

                const title = extractTitle(fullPath) || 
                  path.basename(relativePath, path.extname(relativePath)).replace(/[-_]/g, ' ') +
                  ' ' + path.extname(relativePath).substring(1).toUpperCase();
                const description = extractDescription(fullPath);
                const category = extractCategory(fullPath);
                const icon = category === 'jsx-demo' ? 'âš›ï¸' : 'ðŸ“„';

                const newCard = {
                  icon: icon,
                  title: title,
                  description: description,
                  features: [
                    'Immersive experience',
                    'Interactive content'
                  ],
                  link: link,
                  category: category,
                  highlight: category === 'jsx-demo'
                };

                cardsData.push(newCard);
                addedCount++;
                console.log(`âœ… Added card for ${relativePath} (category: ${category})`);
              }

              if (addedCount === 0) {
                console.log('No new cards to add.');
                return;
              }

              const newCardsDataStr = JSON.stringify(cardsData, null, 2)
                .replace(/"([^"]+)":/g, '$1:');

              const updatedScriptContent = scriptContent.replace(
                /const cardsData = \[[\s\S]*?\];/,
                `const cardsData = ${newCardsDataStr};`
              );

              cardsDataScript.textContent = updatedScriptContent;
              fs.writeFileSync(selectorPath, root.toString());
              console.log('âœ… selector.html updated successfully.');
            })().catch(err => core.setFailed(err.message));

      # ---- Commit changes ----
      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add public/selector.html
          git add public/imagine/compiled
          git add package.json
          git add package-lock.json 2>/dev/null || true
          if ! git diff --staged --quiet; then
            git commit -m "Autoâ€‘update: compile JSX and add cards [skip ci]"
            git push
          else
            echo "No changes to commit; skipping."
          fi
