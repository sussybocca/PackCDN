name: Auto‚Äëlink Imagine Files

on:
  push:
    paths:
      - 'public/imagine/**'          # triggers for any change inside imagine/
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-selector:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install JSX dependencies
        run: |
          # Find all JSX files and extract dependencies
          JSX_DIR="public/imagine/JSX"
          if [ -d "$JSX_DIR" ]; then
            echo "üîç Scanning for JSX files to check dependencies..."
            
            TEMP_DEPS_FILE=$(mktemp)
            
            find "$JSX_DIR" -type f \( -name "*.jsx" -o -name "*.tsx" \) | while read -r file; do
              echo "Checking $file for dependencies..."
              
              grep -E "^import.*from|^import.*['\"]" "$file" | while read -r line; do
                if [[ $line =~ from[[:space:]]+[\'\"]([^\./][^\'\"]*)[\'\"] ]]; then
                  pkg="${BASH_REMATCH[1]}"
                  if [[ $pkg == @*/* ]]; then
                    echo "$pkg" >> "$TEMP_DEPS_FILE"
                  else
                    base_pkg=$(echo "$pkg" | cut -d'/' -f1)
                    echo "$base_pkg" >> "$TEMP_DEPS_FILE"
                  fi
                fi
              done
            done
            
            if [ -s "$TEMP_DEPS_FILE" ]; then
              sort -u "$TEMP_DEPS_FILE" > "${TEMP_DEPS_FILE}_unique"
              DEPS_TO_INSTALL=$(cat "${TEMP_DEPS_FILE}_unique" | tr '\n' ' ')
              
              if [ -n "$DEPS_TO_INSTALL" ]; then
                echo "üì¶ Dependencies found: $DEPS_TO_INSTALL"
                
                for pkg in $DEPS_TO_INSTALL; do
                  echo "üîß Installing $pkg..."
                  
                  if npm list "$pkg" --depth=0 2>/dev/null | grep -q "$pkg"; then
                    echo "‚úÖ $pkg already installed, skipping..."
                  else
                    if npm show "$pkg" version --json 2>/dev/null; then
                      npm install --save-exact "$pkg" --no-package-lock || \
                      npm install "$pkg" --no-package-lock
                    else
                      echo "‚ö†Ô∏è Could not find package $pkg, trying npm install anyway..."
                      npm install "$pkg" --no-package-lock || true
                    fi
                  fi
                done
                
                if [ -f "package-lock.json" ]; then
                  npm install --package-lock-only
                fi
              fi
            else
              echo "No dependencies found in JSX files."
            fi
            
            rm -f "$TEMP_DEPS_FILE" "${TEMP_DEPS_FILE}_unique"
          else
            echo "üìÅ JSX folder not found, skipping dependency installation."
          fi

      - name: Install additional JSX/React dependencies
        run: |
          JSX_DIR="public/imagine/JSX"
          if [ -d "$JSX_DIR" ] && find "$JSX_DIR" -name "*.jsx" -o -name "*.tsx" | grep -q .; then
            echo "üîÑ Checking for common JSX dependencies..."
            
            if find "$JSX_DIR" -type f \( -name "*.jsx" -o -name "*.tsx" \) -exec grep -l "React" {} \; | grep -q .; then
              if ! npm list react --depth=0 2>/dev/null | grep -q react; then
                echo "üì¶ Installing React..."
                npm install --save-exact react react-dom --no-package-lock || \
                npm install react react-dom --no-package-lock
              fi
            fi
            
            if [ -f "package-lock.json" ]; then
              npm install --package-lock-only
            fi
          fi

      - name: Update selector.html with new imagine files
        uses: actions/github-script@v7
        env:
          NODE_PATH: ${{ github.workspace }}/node_modules
        with:
          script: |
            module.exports = async ({ core }) => {
              const fs = require('fs');
              const path = require('path');
              const util = require('util');
              const execAsync = util.promisify(require('child_process').exec);

              const workspace = process.env.GITHUB_WORKSPACE;
              console.log('Workspace:', workspace);
              const nodeModulesPath = path.join(workspace, 'node_modules');
              console.log('Node modules path:', nodeModulesPath);

              // Ensure node-html-parser is installed
              try {
                require.resolve('node-html-parser', { paths: [nodeModulesPath] });
                console.log('node-html-parser is already installed.');
              } catch (e) {
                console.log('node-html-parser not found, installing now...');
                await execAsync('npm install --no-save --no-package-lock node-html-parser', { cwd: workspace });
                console.log('Installation complete.');
              }

              const { parse } = require('node-html-parser');

              const selectorPath = 'public/selector.html';
              const imagineDir = 'public/imagine';

              const selectorHtml = fs.readFileSync(selectorPath, 'utf8');
              const root = parse(selectorHtml);

              const scripts = root.querySelectorAll('script');
              let cardsDataScript = null;
              for (const script of scripts) {
                const content = script.textContent || script.innerHTML;
                if (content.includes('const cardsData = [')) {
                  cardsDataScript = script;
                  break;
                }
              }
              if (!cardsDataScript) {
                core.setFailed('Could not find cardsData array in selector.html');
                return;
              }

              const scriptContent = cardsDataScript.textContent;
              const match = scriptContent.match(/const cardsData = (\[[\s\S]*?\]);/);
              if (!match) {
                core.setFailed('Failed to extract cardsData array');
                return;
              }
              const cardsDataStr = match[1];
              let cardsData;
              try {
                cardsData = eval('(' + cardsDataStr + ')');
              } catch (e) {
                core.setFailed('Error parsing cardsData: ' + e.message);
                return;
              }

              function getAllFiles(dir, baseDir = dir) {
                let results = [];
                const list = fs.readdirSync(dir);
                for (const item of list) {
                  const fullPath = path.join(dir, item);
                  const stat = fs.statSync(fullPath);
                  if (stat.isDirectory()) {
                    results = results.concat(getAllFiles(fullPath, baseDir));
                  } else if (item.endsWith('.html') || item.endsWith('.htm') || 
                            item.endsWith('.jsx') || item.endsWith('.tsx')) {
                    const relativePath = path.relative(baseDir, fullPath);
                    results.push({ fullPath, relativePath });
                  }
                }
                return results;
              }

              if (!fs.existsSync(imagineDir)) {
                console.log('‚ö†Ô∏è  imagine/ folder not found ‚Äì nothing to do.');
                return;
              }

              const files = getAllFiles(imagineDir);
              if (files.length === 0) {
                console.log('No files found in imagine/ ‚Äì nothing to do.');
                return;
              }

              function extractTitle(filePath) {
                try {
                  const content = fs.readFileSync(filePath, 'utf8');
                  
                  if (filePath.endsWith('.jsx') || filePath.endsWith('.tsx')) {
                    const componentMatch = content.match(/export\s+(default\s+)?function\s+(\w+)|const\s+(\w+)\s*=\s*\(?/);
                    if (componentMatch) {
                      return componentMatch[2] || componentMatch[3] || 'React Component';
                    }
                    
                    const commentMatch = content.match(/\/\/\s*@title\s*(.+)|<!--\s*title:\s*(.+)\s*-->/);
                    if (commentMatch) {
                      return (commentMatch[1] || commentMatch[2]).trim();
                    }
                  } else {
                    const doc = parse(content);
                    const titleTag = doc.querySelector('title');
                    return titleTag ? titleTag.text.trim() : null;
                  }
                } catch {
                  return null;
                }
                return null;
              }

              function extractDescription(filePath) {
                try {
                  const content = fs.readFileSync(filePath, 'utf8');
                  
                  if (filePath.endsWith('.jsx') || filePath.endsWith('.tsx')) {
                    const descMatch = content.match(/\/\/\s*@description\s*(.+)|<!--\s*description:\s*(.+)\s*-->/);
                    if (descMatch) {
                      return (descMatch[1] || descMatch[2]).trim();
                    }
                    return 'Interactive React component.';
                  } else {
                    const doc = parse(content);
                    const metaDesc = doc.querySelector('meta[name="description"]');
                    if (metaDesc) {
                      return metaDesc.getAttribute('content') || '';
                    }
                    const firstP = doc.querySelector('p');
                    if (firstP) {
                      return firstP.text.trim().substring(0, 150) + '‚Ä¶';
                    }
                  }
                } catch {}
                return 'Explore this immersive experience.';
              }

              function extractCategory(filePath) {
                try {
                  const content = fs.readFileSync(filePath, 'utf8');
                  
                  if (filePath.endsWith('.jsx') || filePath.endsWith('.tsx')) {
                    const catMatch = content.match(/\/\/\s*@category\s*(.+)|<!--\s*category:\s*(.+)\s*-->/);
                    if (catMatch) {
                      return (catMatch[1] || catMatch[2]).trim();
                    }
                    return 'jsx';
                  } else {
                    const doc = parse(content);
                    const metaCat = doc.querySelector('meta[name="category"]');
                    if (metaCat) {
                      return metaCat.getAttribute('content') || 'demos';
                    }
                  }
                } catch {}
                return filePath.endsWith('.jsx') || filePath.endsWith('.tsx') ? 'jsx' : 'demos';
              }

              function extractIcon(filePath) {
                if (filePath.endsWith('.jsx') || filePath.endsWith('.tsx')) {
                  return '‚öõÔ∏è';
                }
                return 'üìÑ';
              }

              function extractFeatures(filePath) {
                const features = [];
                
                if (filePath.endsWith('.jsx') || filePath.endsWith('.tsx')) {
                  features.push('React component');
                  features.push('Interactive UI');
                  if (filePath.endsWith('.tsx')) {
                    features.push('TypeScript');
                  }
                } else {
                  features.push('Immersive experience');
                  features.push('New dimension');
                  features.push('Interactive content');
                }
                
                return features;
              }

              function cardExists(link) {
                return cardsData.some(card => card.link === link);
              }

              let addedCount = 0;
              for (const { fullPath, relativePath } of files) {
                const link = `imagine/${relativePath.replace(/\\/g, '/')}`;
                if (cardExists(link)) {
                  console.log(`Card for ${relativePath} already exists ‚Äì skipping.`);
                  continue;
                }

                const title = extractTitle(fullPath) || 
                  path.basename(relativePath, path.extname(relativePath)).replace(/[-_]/g, ' ') +
                  ' ' + path.extname(relativePath).substring(1).toUpperCase();
                const description = extractDescription(fullPath);
                const category = extractCategory(fullPath);
                const icon = extractIcon(fullPath);
                const features = extractFeatures(fullPath);

                const newCard = {
                  icon: icon,
                  title: title,
                  description: description,
                  features: features,
                  link: link,
                  category: category,
                  highlight: category === 'jsx'
                };

                cardsData.push(newCard);
                addedCount++;
                console.log(`‚úÖ Added card for ${relativePath} (category: ${category})`);
              }

              if (addedCount === 0) {
                console.log('No new cards to add.');
                return;
              }

              const newCardsDataStr = JSON.stringify(cardsData, null, 2)
                .replace(/"([^"]+)":/g, '$1:');

              const updatedScriptContent = scriptContent.replace(
                /const cardsData = \[[\s\S]*?\];/,
                `const cardsData = ${newCardsDataStr};`
              );

              cardsDataScript.textContent = updatedScriptContent;

              fs.writeFileSync(selectorPath, root.toString());
              console.log('‚úÖ selector.html updated successfully.');
            };

      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add public/selector.html
          git add package.json
          git add package-lock.json 2>/dev/null || true
          
          if ! git diff --staged --quiet; then
            git commit -m "Auto‚Äëupdate: add imagine files and JSX dependencies [skip ci]"
            git push
          else
            echo "No changes to commit; skipping."
          fi
