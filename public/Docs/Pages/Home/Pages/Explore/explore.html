<!DOCTYPE html>
<html>
<head>
  <title>Explore Packs - PackCDN Portal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #0a0a1a;
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    header {
      background: rgba(20, 20, 40, 0.9);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-bottom: 2px solid #667eea;
      box-shadow: 0 0 30px #667eea33;
      z-index: 10;
    }
    
    .header-content {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2.5rem;
      font-weight: 800;
      background: linear-gradient(145deg, #667eea, #9f7aea);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 10px;
    }
    
    .search-box {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }
    
    .search-box input {
      flex: 1;
      padding: 12px;
      border: 1px solid #334155;
      border-radius: 8px;
      background: #1e1e3f;
      color: white;
      font-size: 16px;
    }
    
    .search-box input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 15px #667eea66;
    }
    
    .search-box button {
      padding: 12px 30px;
      background: linear-gradient(145deg, #667eea, #9f7aea);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: 0.2s;
    }
    
    .search-box button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 20px #667eea;
    }
    
    .filters {
      display: flex;
      gap: 10px;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    
    .filter-btn {
      padding: 8px 20px;
      background: rgba(30, 30, 63, 0.8);
      border: 1px solid #4a5568;
      border-radius: 30px;
      color: #e0e7ff;
      cursor: pointer;
      transition: 0.2s;
      font-weight: 500;
    }
    
    .filter-btn.active {
      background: #667eea;
      border-color: #667eea;
      color: white;
      box-shadow: 0 0 15px #667eea;
    }
    
    .game-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      position: relative;
    }
    
    canvas {
      background: #0f0f1f;
      border-radius: 30px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.8), 0 0 0 2px rgba(102, 126, 234, 0.3) inset;
      max-width: 100%;
      height: auto;
      border: 3px solid rgba(255,255,255,0.1);
      display: block;
      width: 100%;
      height: 100%;
      min-height: 500px;
    }
    
    .load-more {
      text-align: center;
      margin: 20px 0 30px;
    }
    
    .load-btn {
      padding: 12px 40px;
      background: rgba(30, 30, 63, 0.9);
      border: 2px solid #667eea;
      color: white;
      border-radius: 40px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      backdrop-filter: blur(5px);
      transition: 0.2s;
    }
    
    .load-btn:hover {
      background: #667eea;
      box-shadow: 0 0 30px #667eea;
    }
    
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #a0aec0;
      background: rgba(0,0,0,0.7);
      padding: 30px;
      border-radius: 20px;
      backdrop-filter: blur(5px);
      border: 1px solid #667eea66;
      z-index: 20;
      pointer-events: none;
    }
    
    .empty-state h3 {
      font-size: 2rem;
      margin-bottom: 10px;
      color: white;
    }
    
    .empty-state a {
      color: #9f7aea;
      text-decoration: none;
      font-weight: bold;
    }
    
    footer {
      text-align: center;
      color: rgba(255,255,255,0.7);
      padding: 20px;
      font-size: 0.9rem;
      background: rgba(0,0,0,0.3);
    }
    
    footer a {
      color: white;
      margin: 0 15px;
      text-decoration: none;
      font-weight: 500;
      transition: 0.2s;
    }
    
    footer a:hover {
      color: #a78bfa;
      text-shadow: 0 0 10px #a78bfa;
    }
    
    @media (max-width: 600px) {
      h1 { font-size: 2rem; }
      .search-box { flex-direction: column; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <h1>âœ¨ Explore Packs â€“ The Game</h1>
      <p>Move with arrow keys or WASD. Touch a gem to open the pack.</p>
      
      <div class="search-box">
        <input type="text" id="searchInput" placeholder="Search packages..." value="">
        <button id="searchBtn">Search</button>
      </div>
      
      <div class="filters">
        <div class="filter-btn active" data-type="all">All</div>
        <div class="filter-btn" data-type="npm">NPM</div>
        <div class="filter-btn" data-type="python">Python</div>
        <div class="filter-btn" data-type="wasm">WASM</div>
      </div>
    </div>
  </header>
  
  <div class="game-container">
    <canvas id="gameCanvas" width="1000" height="600"></canvas>
    <div id="emptyState" class="empty-state" style="display: none;">
      <h3>ðŸŒŒ No packs found</h3>
      <p>Try a different search or create your own pack!</p>
      <a href="editor.html">Create a Pack â†’</a>
    </div>
  </div>
  
  <div class="load-more">
    <button class="load-btn" id="loadMoreBtn" style="display: none;">Load More</button>
  </div>
  
  <footer>
    <a href="editor.html">Create</a>
    <a href="https://github.com/sussybocca/PackCDN/tree/main">GitHub</a>
  </footer>

  <script>
    (function() {
      // ----- Game Setup -----
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Player
      const player = {
        x: 200,
        y: 300,
        radius: 15,
        speed: 5,
        direction: 1,
        walkCycle: 0,
        bounce: 0
      };
      
      // World bounds (keep player inside)
      const minX = player.radius;
      const maxX = canvas.width - player.radius;
      const minY = player.radius;
      const maxY = canvas.height - player.radius;
      
      // Game objects
      let packs = [];               // array of { x, y, radius, color, url, name, type }
      
      // Key states
      const keys = {
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        KeyW: false, KeyA: false, KeyS: false, KeyD: false
      };
      
      // Particles & stars
      let particles = [];
      const PARTICLE_COUNT = 60;
      let stars = [];
      const STAR_COUNT = 150;
      
      // UI state
      let currentPage = 1;
      let currentFilter = 'all';
      let currentSearch = '';
      let hasMore = false;
      let isLoading = false;
      
      // Initialize stars
      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1,
          brightness: Math.random() * 0.7 + 0.3,
        });
      }
      
      // Initialize particles
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 3 + 1,
          speedX: (Math.random() - 0.5) * 0.2,
          speedY: (Math.random() - 0.5) * 0.2,
          color: `hsl(${Math.random() * 60 + 200}, 80%, 70%)`,
          opacity: Math.random() * 0.5 + 0.2
        });
      }
      
      // ----- Helper Functions -----
      function randomPosition() {
        // Try to place away from player start and other packs (simple attempt)
        const margin = 50;
        return {
          x: Math.random() * (canvas.width - 2*margin) + margin,
          y: Math.random() * (canvas.height - 2*margin) + margin
        };
      }
      
      // Map pack type to color
      function getPackColor(type) {
        const t = (type || '').toLowerCase();
        if (t === 'npm' || t === 'javascript' || t === 'typescript') return '#4299e1'; // blue
        if (t === 'python') return '#48bb78'; // green
        if (t === 'wasm') return '#9f7aea';   // purple
        return '#ecc94b'; // yellow / other
      }
      
      // Load packs from API
      async function loadPacks(reset = false) {
        if (isLoading) return;
        isLoading = true;
        
        if (reset) {
          currentPage = 1;
          packs = [];  // clear existing packs
        }
        
        const params = new URLSearchParams({
          page: currentPage,
          limit: 12
        });
        
        if (currentFilter !== 'all') params.set('type', currentFilter);
        if (currentSearch) params.set('q', currentSearch);
        
        try {
          const response = await fetch(`/api/search?${params}`);
          const result = await response.json();
          
          if (result.success) {
            // Convert each pack to a game object
            const newPacks = result.packs.map(pack => {
              // Determine type from packageType or type field
              const packType = pack.packageType || pack.type || 'unknown';
              const pos = randomPosition(); // simplistic; we could improve placement later
              return {
                x: pos.x,
                y: pos.y,
                radius: 18 + Math.random() * 6, // slightly varied size
                color: getPackColor(packType),
                url: `https://packcdn.firefly-worker.workers.dev/pack/${pack.id}`, // or pack.cdnUrl
                name: pack.name,
                type: packType
              };
            });
            
            if (reset) {
              packs = newPacks;
            } else {
              packs = [...packs, ...newPacks];
            }
            
            hasMore = result.pagination?.hasNextPage || false;
            document.getElementById('loadMoreBtn').style.display = hasMore ? 'block' : 'none';
            
            // Show/hide empty state
            if (packs.length === 0) {
              document.getElementById('emptyState').style.display = 'block';
            } else {
              document.getElementById('emptyState').style.display = 'none';
            }
          }
        } catch (error) {
          console.error('Failed to load packs:', error);
        } finally {
          isLoading = false;
        }
      }
      
      // ----- Event Listeners -----
      window.addEventListener('keydown', (e) => {
        if (keys.hasOwnProperty(e.code)) {
          e.preventDefault();
          keys[e.code] = true;
        }
      });
      
      window.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.code)) {
          keys[e.code] = false;
        }
      });
      
      canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      
      // Search
      document.getElementById('searchBtn').addEventListener('click', () => {
        currentSearch = document.getElementById('searchInput').value;
        loadPacks(true);
      });
      
      document.getElementById('searchInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          currentSearch = e.target.value;
          loadPacks(true);
        }
      });
      
      // Filters
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentFilter = btn.dataset.type;
          loadPacks(true);
        });
      });
      
      // Load More
      document.getElementById('loadMoreBtn').addEventListener('click', () => {
        currentPage++;
        loadPacks(false);
      });
      
      // ----- Animation & Drawing -----
      function updateParticles() {
        for (let p of particles) {
          p.x += p.speedX;
          p.y += p.speedY;
          if (p.x < 0) p.x = canvas.width;
          if (p.x > canvas.width) p.x = 0;
          if (p.y < 0) p.y = canvas.height;
          if (p.y > canvas.height) p.y = 0;
        }
      }
      
      function drawStars(time) {
        for (let s of stars) {
          const twinkle = Math.sin(time * 0.002 + s.x) * 0.2 + 0.8;
          ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness * twinkle})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }
      
      function drawPacks() {
        for (let pack of packs) {
          // Glow
          ctx.shadowColor = pack.color;
          ctx.shadowBlur = 25;
          
          // Gem shape (circle with inner highlight)
          const gradient = ctx.createRadialGradient(pack.x-3, pack.y-3, 3, pack.x, pack.y, pack.radius);
          gradient.addColorStop(0, pack.color);
          gradient.addColorStop(1, '#1e1e3f');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(pack.x, pack.y, pack.radius, 0, 2*Math.PI);
          ctx.fill();
          
          // Inner spark
          ctx.shadowBlur = 15;
          ctx.fillStyle = 'rgba(255,255,255,0.6)';
          ctx.beginPath();
          ctx.arc(pack.x-3, pack.y-3, pack.radius*0.2, 0, 2*Math.PI);
          ctx.fill();
          
          // Reset shadow for text
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          
          // Tiny label (optional)
          ctx.font = 'bold 10px Inter, sans-serif';
          ctx.fillStyle = 'white';
          ctx.textAlign = 'center';
          ctx.fillText(pack.name.substring(0, 10) + (pack.name.length>10?'â€¦':''), pack.x, pack.y - pack.radius - 5);
        }
      }
      
      function drawPlayer() {
        const bounceY = player.y + player.bounce + (isMoving ? Math.sin(player.walkCycle) * 2 : 0);
        
        // Shadow
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 15;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(player.x, player.y + player.radius - 5, player.radius-2, 5, 0, 0, 2*Math.PI);
        ctx.fill();
        
        // Body
        const bodyGrad = ctx.createRadialGradient(player.x-5, player.y-5, 5, player.x, player.y, player.radius);
        bodyGrad.addColorStop(0, '#ffdbb5');
        bodyGrad.addColorStop(1, '#e0a87a');
        ctx.fillStyle = bodyGrad;
        ctx.shadowColor = '#a78bfa';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(player.x, bounceY, player.radius, 0, 2*Math.PI);
        ctx.fill();
        
        // Eyes
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) - 2, bounceY - 5, 4, 0, 2*Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) + 2, bounceY - 5, 4, 0, 2*Math.PI);
        ctx.fill();
        
        // Pupils
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) - 2 + (moveX*0.3), bounceY - 5 + (moveY*0.3), 2, 0, 2*Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) + 2 + (moveX*0.3), bounceY - 5 + (moveY*0.3), 2, 0, 2*Math.PI);
        ctx.fill();
        
        // Hat
        const hatY = bounceY - 18;
        ctx.fillStyle = '#3f4d7a';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#5f6b8a';
        ctx.beginPath();
        ctx.ellipse(player.x, hatY, 14, 6, 0, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillRect(player.x-6, hatY-10, 12, 12);
        
        ctx.shadowBlur = 0;
      }
      
      // Game loop variables
      let lastTime = performance.now();
      let isMoving = false;
      let moveX = 0, moveY = 0;
      
      function gameLoop() {
        const now = performance.now();
        const delta = Math.min(16, now - lastTime) / 16;
        lastTime = now;
        
        // Player movement
        let dx = 0, dy = 0;
        if (keys.ArrowUp || keys.KeyW) dy -= 1;
        if (keys.ArrowDown || keys.KeyS) dy += 1;
        if (keys.ArrowLeft || keys.KeyA) dx -= 1;
        if (keys.ArrowRight || keys.KeyD) dx += 1;
        
        isMoving = dx !== 0 || dy !== 0;
        
        if (isMoving) {
          const length = Math.sqrt(dx*dx + dy*dy);
          dx = (dx / length) * player.speed * delta;
          dy = (dy / length) * player.speed * delta;
          
          player.x = Math.min(maxX, Math.max(minX, player.x + dx));
          player.y = Math.min(maxY, Math.max(minY, player.y + dy));
          
          if (dx !== 0) player.direction = dx > 0 ? 1 : -1;
          player.walkCycle = (player.walkCycle + 0.3 * delta) % (Math.PI * 2);
        } else {
          player.bounce = Math.sin(now * 0.008) * 1.5;
          player.walkCycle = 0;
        }
        
        moveX = dx;
        moveY = dy;
        
        // Collision with packs
        for (let i = packs.length - 1; i >= 0; i--) {
          const pack = packs[i];
          const dist = Math.hypot(player.x - pack.x, player.y - pack.y);
          if (dist < player.radius + pack.radius) {
            // Open pack URL in new tab
            window.open(pack.url, '_blank');
            // Optional: remove pack after collection? We'll leave it for now.
            // If you want to remove, uncomment next line:
            // packs.splice(i, 1);
          }
        }
        
        // Update particles
        updateParticles();
        
        // Draw everything
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Background gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#0a0a1a');
        grad.addColorStop(1, '#1a1a3a');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Stars
        drawStars(now);
        
        // Grid floor (glowing)
        ctx.shadowColor = '#4a5fc1';
        ctx.shadowBlur = 15;
        ctx.lineWidth = 1;
        const gridOpacity = 0.15 + Math.sin(now * 0.002) * 0.05;
        ctx.strokeStyle = `rgba(100, 150, 255, ${gridOpacity})`;
        for (let i = 0; i < canvas.width; i += 60) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i < canvas.height; i += 60) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
        
        // Particles
        for (let p of particles) {
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 10;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.opacity;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, 2*Math.PI);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        
        // Packs
        drawPacks();
        
        // Player
        drawPlayer();
        
        requestAnimationFrame(gameLoop);
      }
      
      // Initial load
      loadPacks(true);
      
      // Start loop
      gameLoop();
      
      // Handle resize (keep canvas sharp)
      window.addEventListener('resize', () => {
        // Maintain aspect ratio if needed; we keep fixed size for simplicity
      });
    })();
  </script>
</body>
</html>
