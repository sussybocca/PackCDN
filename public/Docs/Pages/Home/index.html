<!DOCTYPE html>
<html>
<head>
  <title>PackCDN - Enhanced Portal Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      line-height: 1.6;
      color: #333;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      text-align: center;
      color: white;
      padding: 40px 20px 20px;
    }
    
    .header h1 {
      font-size: 3rem;
      margin-bottom: 10px;
      font-weight: 800;
      text-shadow: 0 4px 20px rgba(102, 126, 234, 0.6);
    }
    
    .header p {
      font-size: 1.2rem;
      opacity: 0.9;
      text-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    
    .game-container {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      flex: 1;
    }
    
    canvas {
      background: #0f0f1f;
      border-radius: 30px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.8), 0 0 0 2px rgba(102, 126, 234, 0.3) inset;
      max-width: 100%;
      height: auto;
      border: 3px solid rgba(255,255,255,0.1);
      display: block;
    }
    
    .controls {
      text-align: center;
      color: white;
      padding: 20px;
      font-size: 1rem;
      background: rgba(0,0,0,0.4);
      margin: 0 20px 20px;
      border-radius: 50px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    
    .controls kbd {
      background: rgba(255,255,255,0.15);
      padding: 6px 12px;
      border-radius: 8px;
      margin: 0 4px;
      border: 1px solid rgba(255,255,255,0.3);
      font-size: 1.1rem;
      color: #fff;
    }
    
    footer {
      text-align: center;
      color: rgba(255,255,255,0.7);
      padding: 20px;
      font-size: 0.9rem;
      margin-top: auto;
    }
    
    footer a {
      color: white;
      margin: 0 15px;
      text-decoration: none;
      font-weight: 500;
      transition: 0.2s;
    }
    
    footer a:hover {
      color: #a78bfa;
      text-shadow: 0 0 10px #a78bfa;
    }
    
    @media (max-width: 600px) {
      .header h1 { font-size: 2rem; }
      canvas { width: 100%; height: auto; }
      .controls kbd { padding: 4px 8px; font-size: 0.9rem; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üöÄ PackCDN Portal</h1>
    <p>Move with arrow keys or WASD. Touch a portal to enter.</p>
  </div>
  
  <div class="game-container">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
  </div>
  
  <div class="controls">
    <span><kbd>‚Üë</kbd> <kbd>‚Üì</kbd> <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> or <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> to move</span>
    <span style="margin-left: 30px;">üîµ Create Pack &nbsp;&nbsp; üü£ Explore Packs</span>
  </div>
  
  <footer>
    <a href="Pages/Editor/editor.html">Create</a>
    <a href="Pages/Explore/explore.html">Explore</a>
    <a href="https://github.com/sussybocca/PackCDN/tree/main">GitHub</a>
  </footer>

  <script>
    (function() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      // ========== ENHANCED SETTINGS ==========
      const player = {
        x: 400,
        y: 250,
        radius: 16,
        speed: 4,
        walkCycle: 0,        // for leg movement
        bounce: 0,           // idle bounce
        direction: 1,        // facing direction (1 right, -1 left)
        hatAngle: 0
      };

      const portals = [
        { x: 100, y: 250, width: 90, height: 130, color: '#667eea', color2: '#5a67d8', label: 'CREATE', url: 'Pages/Editor/editor.html', angle: 0 },
        { x: 700, y: 250, width: 90, height: 130, color: '#9f7aea', color2: '#8b5cf6', label: 'EXPLORE', url: 'Pages/Explore/explore.html', angle: 0 }
      ];

      // Particle system
      let particles = [];
      const PARTICLE_COUNT = 80;

      // Starfield
      let stars = [];
      const STAR_COUNT = 200;

      // Boundaries
      const minX = player.radius;
      const maxX = canvas.width - player.radius;
      const minY = player.radius;
      const maxY = canvas.height - player.radius;

      // Key state
      const keys = {
        ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
        KeyW: false, KeyA: false, KeyS: false, KeyD: false
      };

      // Movement flags (for drawing)
      let isMoving = false;
      let moveX = 0, moveY = 0;

      // ========== INITIALIZE PARTICLES AND STARS ==========
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 3 + 1,
          speedX: (Math.random() - 0.5) * 0.2,
          speedY: (Math.random() - 0.5) * 0.2,
          color: `hsl(${Math.random() * 60 + 200}, 80%, 70%)`,
          opacity: Math.random() * 0.5 + 0.3
        });
      }

      for (let i = 0; i < STAR_COUNT; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 1,
          brightness: Math.random() * 0.7 + 0.3,
          speed: Math.random() * 0.02 + 0.01
        });
      }

      // ========== EVENT LISTENERS ==========
      window.addEventListener('keydown', (e) => {
        if (keys.hasOwnProperty(e.code)) {
          e.preventDefault();
          keys[e.code] = true;
        }
      });

      window.addEventListener('keyup', (e) => {
        if (keys.hasOwnProperty(e.code)) {
          keys[e.code] = false;
        }
      });

      canvas.addEventListener('contextmenu', (e) => e.preventDefault());

      // ========== HELPER FUNCTIONS ==========
      function updateParticles() {
        for (let p of particles) {
          p.x += p.speedX;
          p.y += p.speedY;
          if (p.x < 0) p.x = canvas.width;
          if (p.x > canvas.width) p.x = 0;
          if (p.y < 0) p.y = canvas.height;
          if (p.y > canvas.height) p.y = 0;
        }
      }

      function drawStars(time) {
        for (let s of stars) {
          // Twinkling effect
          const twinkle = Math.sin(time * 3 + s.x) * 0.2 + 0.8;
          ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness * twinkle})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      function drawGlow(x, y, radius, color) {
        ctx.shadowColor = color;
        ctx.shadowBlur = radius * 2;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
      }

      // ========== MAIN GAME LOOP ==========
      let lastTime = performance.now();
      function update() {
        const now = performance.now();
        const delta = Math.min(16, now - lastTime) / 16; // normalize to ~60fps
        lastTime = now;

        // --- Player movement ---
        let dx = 0, dy = 0;
        if (keys.ArrowUp || keys.KeyW) dy -= 1;
        if (keys.ArrowDown || keys.KeyS) dy += 1;
        if (keys.ArrowLeft || keys.KeyA) dx -= 1;
        if (keys.ArrowRight || keys.KeyD) dx += 1;

        isMoving = dx !== 0 || dy !== 0;

        if (isMoving) {
          const length = Math.sqrt(dx*dx + dy*dy);
          dx = (dx / length) * player.speed * delta;
          dy = (dy / length) * player.speed * delta;
          
          player.x = Math.min(maxX, Math.max(minX, player.x + dx));
          player.y = Math.min(maxY, Math.max(minY, player.y + dy));

          // Update direction for walking animation
          if (dx !== 0) player.direction = dx > 0 ? 1 : -1;
          
          // Walk cycle (leg movement)
          player.walkCycle = (player.walkCycle + 0.3 * delta) % (Math.PI * 2);
        } else {
          // Idle bounce
          player.bounce = Math.sin(now * 0.008) * 1.5;
          player.walkCycle = 0;
        }

        // Store movement for drawing (pupils follow)
        moveX = dx;
        moveY = dy;

        // --- Portal collision ---
        for (let portal of portals) {
          const left = portal.x - portal.width/2;
          const right = portal.x + portal.width/2;
          const top = portal.y - portal.height/2;
          const bottom = portal.y + portal.height/2;
          
          const closestX = Math.max(left, Math.min(player.x, right));
          const closestY = Math.max(top, Math.min(player.y, bottom));
          const distance = Math.sqrt((player.x - closestX)**2 + (player.y - closestY)**2);
          
          if (distance < player.radius) {
            window.location.href = portal.url;
            return;
          }
        }

        // --- Update portal angles for animation ---
        for (let portal of portals) {
          portal.angle += 0.02;
        }

        // --- Update particles ---
        updateParticles();

        // --- Draw everything ---
        draw(now);

        requestAnimationFrame(update);
      }

      function draw(time) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ===== BACKGROUND =====
        // Deep space gradient
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#0a0a1a');
        gradient.addColorStop(1, '#1a1a3a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Stars (parallax)
        drawStars(time);

        // ===== FLOOR with glowing grid =====
        ctx.shadowColor = '#4a5fc1';
        ctx.shadowBlur = 15;
        ctx.lineWidth = 1.5;
        
        // Grid lines with pulsing opacity
        const gridOpacity = 0.2 + Math.sin(time * 0.002) * 0.1;
        for (let i = 0; i < canvas.width; i += 50) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.strokeStyle = `rgba(100, 150, 255, ${gridOpacity})`;
          ctx.stroke();
        }
        for (let i = 0; i < canvas.height; i += 50) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
          ctx.stroke();
        }
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        // ===== PARTICLES (floating orbs) =====
        for (let p of particles) {
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 10;
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.opacity;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, 2*Math.PI);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;

        // ===== PORTALS (enhanced) =====
        for (let portal of portals) {
          // Outer glow
          ctx.shadowColor = portal.color;
          ctx.shadowBlur = 50;
          
          // Portal base with gradient
          const grad = ctx.createRadialGradient(portal.x, portal.y, 10, portal.x, portal.y, portal.width/2);
          grad.addColorStop(0, portal.color);
          grad.addColorStop(0.7, portal.color2);
          grad.addColorStop(1, 'rgba(0,0,0,0.8)');
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.ellipse(portal.x, portal.y, portal.width/2, portal.height/2, 0, 0, 2*Math.PI);
          ctx.fill();
          
          // Inner rotating ring
          ctx.save();
          ctx.translate(portal.x, portal.y);
          ctx.rotate(portal.angle);
          ctx.shadowBlur = 30;
          ctx.fillStyle = 'rgba(255,255,255,0.2)';
          ctx.beginPath();
          ctx.ellipse(0, 0, portal.width/3, portal.height/3, 0, 0, 2*Math.PI);
          ctx.fill();
          
          // Second ring (counter-rotating)
          ctx.rotate(-portal.angle * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.ellipse(0, 0, portal.width/4, portal.height/4, 0, 0, 2*Math.PI);
          ctx.fill();
          ctx.restore();

          // Sparkles around portal
          for (let i = 0; i < 5; i++) {
            const angle = (time * 0.005 + i) * 2;
            const sx = portal.x + Math.cos(angle + portal.angle) * 50;
            const sy = portal.y + Math.sin(angle * 2) * 30;
            drawGlow(sx, sy, 4, portal.color);
          }

          // Reset shadow
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          
          // Label with glow
          ctx.shadowColor = portal.color;
          ctx.shadowBlur = 20;
          ctx.fillStyle = 'white';
          ctx.font = 'bold 24px Inter, -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(portal.label, portal.x, portal.y - 70);
          ctx.shadowBlur = 0;
        }

        // ===== PLAYER (enhanced) =====
        const bounceY = player.y + player.bounce + (isMoving ? Math.sin(player.walkCycle) * 2 : 0);

        // Shadow under player
        ctx.shadowColor = 'rgba(0,0,0,0.8)';
        ctx.shadowBlur = 15;
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(player.x, player.y + player.radius - 5, player.radius-2, 5, 0, 0, 2*Math.PI);
        ctx.fill();

        // Body (with gradient)
        const bodyGrad = ctx.createRadialGradient(player.x-5, player.y-5, 5, player.x, player.y, player.radius);
        bodyGrad.addColorStop(0, '#ffdbb5');
        bodyGrad.addColorStop(1, '#e0a87a');
        ctx.fillStyle = bodyGrad;
        ctx.shadowColor = '#a78bfa';
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(player.x, bounceY, player.radius, 0, 2*Math.PI);
        ctx.fill();

        // Eyes with direction
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) - 2, bounceY - 5, 4, 0, 2*Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) + 2, bounceY - 5, 4, 0, 2*Math.PI);
        ctx.fill();

        // Pupils (follow movement slightly)
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) - 2 + (moveX * 0.3), bounceY - 5 + (moveY * 0.3), 2, 0, 2*Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x + (player.direction * 4) + 2 + (moveX * 0.3), bounceY - 5 + (moveY * 0.3), 2, 0, 2*Math.PI);
        ctx.fill();

        // Hat with bounce
        const hatY = bounceY - 18 + Math.sin(time*0.01)*1;
        ctx.fillStyle = '#3f4d7a';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#5f6b8a';
        ctx.beginPath();
        ctx.ellipse(player.x, hatY, 14, 6, 0, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillRect(player.x-6, hatY-10, 12, 12);

        // Reset shadows
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
      }

      // Start animation
      update();
    })();
  </script>
</body>
</html>
